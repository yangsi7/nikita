"""Life simulation stage - generates daily events for Nikita (T2.5).

Non-critical: logs error on failure, continues.
"""

from __future__ import annotations

from contextlib import asynccontextmanager
from typing import TYPE_CHECKING, Any

import structlog

from nikita.pipeline.stages.base import BaseStage
from nikita.pipeline.models import PipelineContext

if TYPE_CHECKING:
    from sqlalchemy.ext.asyncio import AsyncSession

logger = structlog.get_logger(__name__)


def _wrap_session_as_factory(session: AsyncSession):
    """Wrap an existing AsyncSession as a session factory for EventStore.

    EventStore expects a callable that returns an async context manager
    (like async_sessionmaker). This wrapper yields the existing pipeline
    session without creating a new one or closing it.
    """

    @asynccontextmanager
    async def _factory():
        yield session

    return _factory


class LifeSimStage(BaseStage):
    """Run life simulation to generate daily events for Nikita.

    Non-critical: failure does not stop the pipeline.
    Passes pipeline session to EventStore via factory wrapper to avoid
    separate DB connections and SQL failures from session mismatch.
    """

    name = "life_sim"
    is_critical = False
    timeout_seconds = 60.0

    def __init__(self, session: AsyncSession = None, **kwargs) -> None:
        super().__init__(session=session, **kwargs)

    async def _run(self, ctx: PipelineContext) -> dict | None:
        """Generate life events via LifeSimulator.

        Uses get_today_events (read-only) instead of generate_next_day_events
        (write, LLM-dependent) to avoid SQL cascading failures. Falls back to
        empty list on any error. Passes pipeline session to EventStore to
        reuse the existing DB connection.
        """
        try:
            from nikita.life_simulation import LifeSimulator
            from nikita.life_simulation.store import EventStore

            # Pass pipeline session to EventStore to avoid separate DB connections
            store = EventStore(session_factory=_wrap_session_as_factory(self._session)) if self._session else None
            simulator = LifeSimulator(store=store)

            # Prefer reading today's events (already generated by pg_cron)
            # rather than generating new ones (expensive LLM call + write)
            events = await simulator.get_today_events(user_id=ctx.user_id)

            if not events:
                # Fallback: try generating if none exist yet
                events = await simulator.generate_next_day_events(
                    user_id=ctx.user_id,
                )

            ctx.life_events = events or []
            return {"events_generated": len(ctx.life_events)}
        except Exception as e:
            logger.error(
                "life_sim_failed",
                error=str(e),
                error_type=type(e).__name__,
                user_id=str(ctx.user_id),
            )
            ctx.life_events = []
            return {"events_generated": 0, "error": str(e)[:100]}
