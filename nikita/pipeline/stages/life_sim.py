"""Life simulation stage - generates daily events for Nikita (T2.5).

Non-critical: logs error on failure, continues.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

import structlog

from nikita.pipeline.stages.base import BaseStage
from nikita.pipeline.models import PipelineContext

if TYPE_CHECKING:
    from sqlalchemy.ext.asyncio import AsyncSession

logger = structlog.get_logger(__name__)


class LifeSimStage(BaseStage):
    """Run life simulation to generate daily events for Nikita.

    Non-critical: failure does not stop the pipeline.
    Spec 045 WP-5a: Passes pipeline session to EventStore for session reuse,
    wraps in try/except to return empty list on failure.
    """

    name = "life_sim"
    is_critical = False
    timeout_seconds = 60.0

    def __init__(self, session: AsyncSession = None, **kwargs) -> None:
        super().__init__(session=session, **kwargs)

    async def _run(self, ctx: PipelineContext) -> dict | None:
        """Generate life events via LifeSimulator.

        Spec 045 WP-5a: Uses get_today_events (read-only) instead of
        generate_next_day_events (write, LLM-dependent) to avoid SQL
        cascading failures. Falls back to empty list on any error.
        """
        try:
            from nikita.life_simulation import LifeSimulator

            simulator = LifeSimulator()

            # Prefer reading today's events (already generated by pg_cron)
            # rather than generating new ones (expensive LLM call + write)
            events = await simulator.get_today_events(user_id=ctx.user_id)

            if not events:
                # Fallback: try generating if none exist yet
                events = await simulator.generate_next_day_events(
                    user_id=ctx.user_id,
                )

            ctx.life_events = events or []
            return {"events_generated": len(ctx.life_events)}
        except Exception as e:
            logger.warning("life_sim_failed, using empty events: %s", str(e))
            ctx.life_events = []
            return {"events_generated": 0, "error": str(e)[:100]}
