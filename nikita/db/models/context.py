"""Context engineering models for post-processing pipeline.

These models support the spec 012 redesign:
- ConversationThread: Tracks unresolved topics, questions, promises
- NikitaThought: Simulates Nikita's inner life between conversations
"""

from datetime import datetime
from typing import TYPE_CHECKING
from uuid import UUID

from sqlalchemy import DateTime, ForeignKey, Text
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from nikita.db.models.base import Base, UUIDMixin

if TYPE_CHECKING:
    from nikita.db.models.conversation import Conversation
    from nikita.db.models.user import User


# Valid thread types
THREAD_TYPES = [
    "follow_up",  # Things to follow up on
    "question",   # Questions asked but not answered
    "promise",    # Promises made by either party
    "topic",      # Topics worth revisiting
]

# Valid thread statuses
THREAD_STATUSES = [
    "open",      # Still active
    "resolved",  # Addressed in conversation
    "expired",   # No longer relevant
]

# Valid thought types
THOUGHT_TYPES = [
    "thinking",        # What she's thinking about from conversation
    "wants_to_share",  # Things she wants to bring up next time
    "question",        # Questions she has for him
    "feeling",         # Her emotional state/feelings
    "missing_him",     # "Missing you" thoughts (scaled by time gap)
]


class ConversationThread(Base, UUIDMixin):
    """
    Tracks unresolved conversation threads.

    Extracted by the post-processing pipeline to identify:
    - Topics to follow up on
    - Questions that weren't answered
    - Promises made by either party
    - Interesting topics worth revisiting

    Used in system prompt generation to give Nikita continuity.
    """

    __tablename__ = "conversation_threads"

    user_id: Mapped[UUID] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
    )

    # Thread classification
    thread_type: Mapped[str] = mapped_column(
        Text,
        nullable=False,
    )  # One of THREAD_TYPES

    # The actual content of the thread
    content: Mapped[str] = mapped_column(Text, nullable=False)

    # Source conversation (nullable if manually created)
    source_conversation_id: Mapped[UUID | None] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("conversations.id", ondelete="SET NULL"),
        nullable=True,
    )

    # Thread state
    status: Mapped[str] = mapped_column(
        Text,
        default="open",
        nullable=False,
    )  # One of THREAD_STATUSES

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
    )
    resolved_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )

    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="conversation_threads")
    source_conversation: Mapped["Conversation | None"] = relationship(
        "Conversation",
        back_populates="threads",
    )


class NikitaThought(Base, UUIDMixin):
    """
    Simulates Nikita's inner life between conversations.

    Generated by the post-processing pipeline to create a sense
    that Nikita has thoughts, feelings, and an inner life when
    she's not actively chatting.

    Used in system prompt generation (Layer 5: Knowledge & Inner Life).
    """

    __tablename__ = "nikita_thoughts"

    user_id: Mapped[UUID] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
    )

    # Thought classification
    thought_type: Mapped[str] = mapped_column(
        Text,
        nullable=False,
    )  # One of THOUGHT_TYPES

    # The actual thought content
    content: Mapped[str] = mapped_column(Text, nullable=False)

    # Source conversation (nullable if simulated without conversation)
    source_conversation_id: Mapped[UUID | None] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("conversations.id", ondelete="SET NULL"),
        nullable=True,
    )

    # Lifecycle
    expires_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )  # Some thoughts expire (e.g., "missing_him" after he messages)

    used_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )  # When this thought was incorporated into conversation

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
    )

    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="thoughts")
    source_conversation: Mapped["Conversation | None"] = relationship(
        "Conversation",
        back_populates="generated_thoughts",
    )

    @property
    def is_active(self) -> bool:
        """Check if thought is still active (not used, not expired)."""
        from nikita.db.models.base import utc_now

        if self.used_at is not None:
            return False
        if self.expires_at is not None and self.expires_at < utc_now():
            return False
        return True
