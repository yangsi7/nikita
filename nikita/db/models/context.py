"""Context engineering models for post-processing pipeline.

These models support the spec 012 redesign:
- ConversationThread: Tracks unresolved topics, questions, promises
- NikitaThought: Simulates Nikita's inner life between conversations
"""

from datetime import datetime
from typing import TYPE_CHECKING
from uuid import UUID

from sqlalchemy import DateTime, ForeignKey, Text
from sqlalchemy.dialects.postgresql import JSONB, UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from nikita.db.models.base import Base, UUIDMixin

if TYPE_CHECKING:
    from nikita.db.models.conversation import Conversation
    from nikita.db.models.user import User


# Valid thread types (MetaPrompt primary + legacy for backwards compatibility)
THREAD_TYPES = [
    # MetaPrompt types (entity_extraction.meta.md) - PRIMARY
    "unresolved",   # Question asked but not fully answered
    "cliffhanger",  # Story started but not finished
    "promise",      # Something to do/discuss later
    "curiosity",    # Topic Nikita should ask more about
    "callback",     # Reference to revisit for continuity
    # Legacy types (backwards compatibility with existing data)
    "follow_up",    # Things to follow up on
    "question",     # Questions asked but not answered
    "topic",        # Topics worth revisiting
]

# Valid thread statuses
THREAD_STATUSES = [
    "open",      # Still active
    "resolved",  # Addressed in conversation
    "expired",   # No longer relevant
]

# Valid thought types (MetaPrompt primary + legacy + Spec 035 psychological)
THOUGHT_TYPES = [
    # MetaPrompt types (entity_extraction.meta.md) - PRIMARY
    "worry",         # Something concerning about the user
    "curiosity",     # Something she wants to know more about
    "anticipation",  # Something she's looking forward to
    "reflection",    # Something that made her think
    "desire",        # Something she wants from/with the user
    # Legacy types (backwards compatibility with existing data)
    "thinking",      # What she's thinking about from conversation
    "wants_to_share",# Things she wants to bring up next time
    "question",      # Questions she has for him
    "feeling",       # Her emotional state/feelings
    "missing_him",   # "Missing you" thoughts (scaled by time gap)
    # Spec 035: Psychological thought types
    "trigger_response",  # Reaction to a trauma trigger
    "defense_active",    # Defense mechanism in play
    "wound_surfacing",   # Core wound being touched
    "attachment_shift",  # Change in attachment behavior
    "healing_moment",    # Positive moment that builds trust
]


class ConversationThread(Base, UUIDMixin):
    """
    Tracks unresolved conversation threads.

    Extracted by the post-processing pipeline to identify:
    - Topics to follow up on
    - Questions that weren't answered
    - Promises made by either party
    - Interesting topics worth revisiting

    Used in system prompt generation to give Nikita continuity.
    """

    __tablename__ = "conversation_threads"

    user_id: Mapped[UUID] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
    )

    # Thread classification
    thread_type: Mapped[str] = mapped_column(
        Text,
        nullable=False,
    )  # One of THREAD_TYPES

    # The actual content of the thread
    content: Mapped[str] = mapped_column(Text, nullable=False)

    # Source conversation (nullable if manually created)
    source_conversation_id: Mapped[UUID | None] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("conversations.id", ondelete="SET NULL"),
        nullable=True,
    )

    # Thread state
    status: Mapped[str] = mapped_column(
        Text,
        default="open",
        nullable=False,
    )  # One of THREAD_STATUSES

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
    )
    resolved_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )

    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="conversation_threads")
    source_conversation: Mapped["Conversation | None"] = relationship(
        "Conversation",
        back_populates="threads",
    )


class NikitaThought(Base, UUIDMixin):
    """
    Simulates Nikita's inner life between conversations.

    Generated by the post-processing pipeline to create a sense
    that Nikita has thoughts, feelings, and an inner life when
    she's not actively chatting.

    Used in system prompt generation (Layer 5: Knowledge & Inner Life).
    """

    __tablename__ = "nikita_thoughts"

    user_id: Mapped[UUID] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
    )

    # Thought classification
    thought_type: Mapped[str] = mapped_column(
        Text,
        nullable=False,
    )  # One of THOUGHT_TYPES

    # The actual thought content
    content: Mapped[str] = mapped_column(Text, nullable=False)

    # Source conversation (nullable if simulated without conversation)
    source_conversation_id: Mapped[UUID | None] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("conversations.id", ondelete="SET NULL"),
        nullable=True,
    )

    # Lifecycle
    expires_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )  # Some thoughts expire (e.g., "missing_him" after he messages)

    used_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )  # When this thought was incorporated into conversation

    # Spec 035: Psychological context (optional metadata for psychological thoughts)
    # Contains: emotional_reaction, relationship_assessment, triggers_activated,
    # attachment_mode, healing_potential
    psychological_context: Mapped[dict | None] = mapped_column(
        JSONB,
        nullable=True,
        default=None,
    )  # JSON field for psychological metadata

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
    )

    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="thoughts")
    source_conversation: Mapped["Conversation | None"] = relationship(
        "Conversation",
        back_populates="generated_thoughts",
    )

    @property
    def is_active(self) -> bool:
        """Check if thought is still active (not used, not expired)."""
        from nikita.db.models.base import utc_now

        if self.used_at is not None:
            return False
        if self.expires_at is not None and self.expires_at < utc_now():
            return False
        return True
